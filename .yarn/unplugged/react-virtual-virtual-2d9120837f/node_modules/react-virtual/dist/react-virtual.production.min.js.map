{"version":3,"file":"react-virtual.production.min.js","sources":["../src/useIsomorphicLayoutEffect.js","../node_modules/@reach/observe-rect/dist/observe-rect.esm.js","../src/useRect.js","../src/index.js","../src/useScroll.js"],"sourcesContent":["import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import React from 'react'\n\nimport observeRect from '@reach/observe-rect'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(nodeRef) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, setRect] = React.useState(null)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      setRect(element.getBoundingClientRect())\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, setRect)\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n","import React from 'react'\n\nimport useScroll from './useScroll'\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 0,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n\n  const { [sizeKey]: outerSize } = useRect(parentRef) || {\n    [sizeKey]: 0,\n  }\n\n  const [scrollOffset, _setScrollOffset] = React.useState(0)\n\n  const scrollOffsetPlusOuterSize = scrollOffset + outerSize\n\n  useScroll(parentRef, ({ [scrollKey]: newScrollOffset }) => {\n    _setScrollOffset(newScrollOffset)\n  })\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        _setScrollOffset(offset)\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  scrollToFn = React.useCallback(\n    offset => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const { measurements, reversedMeasurements } = React.useMemo(() => {\n    const measurements = []\n    const reversedMeasurements = []\n\n    for (let i = 0, j = size - 1; i < size; i++, j--) {\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size = measuredCache[i] || estimateSize(i)\n      const end = start + size\n      const bounds = { index: i, start, size, end }\n      measurements[i] = {\n        ...bounds,\n      }\n      reversedMeasurements[j] = {\n        ...bounds,\n      }\n    }\n    return { measurements, reversedMeasurements }\n  }, [estimateSize, measuredCache, paddingStart, size])\n\n  const totalSize = (measurements[size - 1]?.end || 0) + paddingEnd\n\n  let start = React.useMemo(\n    () =>\n      reversedMeasurements.reduce(\n        (last, rowStat) => (rowStat.end >= scrollOffset ? rowStat : last),\n        reversedMeasurements[0]\n      ),\n    [reversedMeasurements, scrollOffset]\n  )\n\n  let end = React.useMemo(\n    () =>\n      measurements.reduce(\n        (last, rowStat) =>\n          rowStat.start <= scrollOffsetPlusOuterSize ? rowStat : last,\n        measurements[0]\n      ),\n    [measurements, scrollOffsetPlusOuterSize]\n  )\n\n  let startIndex = start ? start.index : 0\n  let endIndex = end ? end.index : 0\n\n  // Always add at least one overscan item, so focus will work\n  startIndex = Math.max(startIndex - overscan, 0)\n  endIndex = Math.min(endIndex + overscan, size - 1)\n\n  const latestRef = React.useRef({})\n\n  latestRef.current = {\n    measurements,\n    outerSize,\n    scrollOffset,\n    scrollOffsetPlusOuterSize,\n    totalSize,\n  }\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let i = startIndex; i <= endIndex; i++) {\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          const { scrollOffset } = latestRef.current\n\n          if (el) {\n            const { [sizeKey]: measuredSize } = el.getBoundingClientRect()\n\n            if (measuredSize !== item.size) {\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              setMeasuredCache(old => ({\n                ...old,\n                [i]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [startIndex, endIndex, measurements, sizeKey, defaultScrollToFn])\n\n  const mountedRef = React.useRef()\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      if (estimateSize || size) setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize, size])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}) => {\n      const {\n        outerSize,\n        scrollOffset,\n        scrollOffsetPlusOuterSize,\n      } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (scrollOffset >= scrollOffsetPlusOuterSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset)\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const {\n        measurements,\n        scrollOffset,\n        scrollOffsetPlusOuterSize,\n      } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffsetPlusOuterSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n  }\n}\n","import React from 'react'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useScroll(nodeRef, onChange) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const onChangeRef = React.useRef()\n  onChangeRef.current = onChange\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element) {\n      onChangeRef.current({\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop,\n      })\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const handler = e => {\n      onChangeRef.current({\n        scrollLeft: e.target.scrollLeft,\n        scrollTop: e.target.scrollTop,\n      })\n    }\n\n    element.addEventListener('scroll', handler, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', handler)\n    }\n  }, [element])\n}\n"],"names":["window","React","useLayoutEffect","useEffect","rafId","props","observedNodes","Map","run","changedStates","state","node","a","b","newRect","getBoundingClientRect","rect","some","prop","cb","useRect","nodeRef","useState","current","element","setElement","setRect","initialRectSet","useRef","useIsomorphicLayoutEffect","observer","observe","wasEmpty","undefined","hasRectChanged","callbacks","unobserve","index","length","size","cancelAnimationFrame","defaultEstimateSize","estimateSize","overscan","paddingStart","paddingEnd","parentRef","horizontal","scrollToFn","sizeKey","scrollKey","outerSize","scrollOffset","_setScrollOffset","scrollOffsetPlusOuterSize","onChange","onChangeRef","scrollLeft","scrollTop","handler","e","target","addEventListener","capture","passive","removeEventListener","useScroll","newScrollOffset","defaultScrollToFn","useCallback","offset","resolvedScrollToFn","measuredCache","setMeasuredCache","useMemo","measurements","reversedMeasurements","i","j","start","end","bounds","totalSize","reduce","last","rowStat","startIndex","endIndex","Math","max","min","latestRef","virtualItems","item","measureRef","el","measuredSize","old","push","mountedRef","scrollToOffset","toOffset","align","tryScrollToIndex","rest","measurement","scrollToIndex","args","requestAnimationFrame"],"mappings":"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"}